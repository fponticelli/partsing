<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>ParTSing</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="./images/favicon.ico">
	      <link rel="stylesheet" href="./styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="./" class="navbar-brand">ParTSing</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content getting-started">
                   <div class="content-data">

<h1 id="partsing">ParTSing</h1>
<p><em>ParTSing</em> is a decoder combinator library. You can use it to build parsers/decoders from string or really any input values.</p>
<p>If you want full control over what to decode your should start from <code>partsing/core/decoder</code>. It provides 3 types parameters</p>
<ul>
<li><code>In</code> for the input. Remember that you will need to decode one portion of your input at the time and your input probably needs to track somehow the current position.</li>
<li><code>Out</code> it&#39;s the type of the value if successfully decoded.</li>
<li><code>Err</code> it&#39;s the type of the failure returned when the parser fails.</li>
</ul>
<p>The library provides two additional set of utility functions to decode <code>string</code> values (<code>partsing/text</code>) and native JS values (<code>partsing/value</code>).</p>
<h2 id="decoder-error">Decoder Error</h2>
<p>If you adopt the generic <code>Decoder</code> directly, you can define the shape of your error. The library provides a <code>DecoderError</code> type that should fit most decoding needs. The type of errors available are defined in <code>partsing/error</code>.</p>
<p><code>DecoderError</code> provides a simple method to debug the result of the decoding (<code>toString</code>) but still leaves the flexibility to give granular control on the representation of the error.</p>
<p>Both [Text Decoding] and [Value Decoding] use <code>DecodeError</code>.</p>
<h2 id="text-decoding">Text Decoding</h2>
<p>To be able to keep track of the position of the decoding within a <code>string</code>, Text Decoding uses <code>TextInput</code> to track both the entire text <code>input</code> and the current <code>index</code>.</p>
<p>The <code>decodeText</code> function simplifies the inputs and outputs of decoding text. It takes a text decoder (<code>Decoder&lt;TextInput, T, DecoderError&gt;</code>) and return a function that takes a string input and returns a <code>DecodeResult&lt;string, T, string&gt;</code> (where input and error are of type <code>string</code>).</p>
<p>If you intend to write your own regular expressions decoder functions, consider using the <code>y</code> (<code>sticky</code>) flag. When used, there is no need to reallocate slices of the input string saving memory and CPU cycles. The <code>sticky</code> flag is not available for all implementations of JS.</p>
<h2 id="value-decoding">Value Decoding</h2>
<p>To be able to keep track of the position of the decoding within <code>any</code> value, Value Decoding uses <code>ValueInput</code> to track both the <code>input</code> value and the current position within it using a <code>path</code>. <code>path</code> is an array of either <code>string</code> (object field name) or <code>number</code> (array/tuple index position).</p>
<p>The <code>decodeValue</code> function simplifies the inputs and outputs of decoding values. It takes a value decoder (<code>Decoder&lt;ValueInput, T, DecoderError&gt;</code>) and return a function that takes <code>any</code> and returns a <code>DecodeResult&lt;any, T, string&gt;</code> (where input is of type <code>any</code> and error is of type <code>string</code>).</p>
<h2 id="example">Example</h2>
<p>A simple decoder combinator to parse color values from strings into class instances.</p>
<div><pre class="line-numbers"><code class="language-typescript">class RGB {
  constructor(readonly rgb: number) {}
}

class Grey {
  constructor(readonly value: number) {}
}

class HSL {
  constructor(readonly hue: number, readonly saturation: number, readonly lightness: number) {}
}

type Color = RGB | Grey | HSL

const ratioDecoder = regexp(/0[.]\d+/y).map(Number)
const rgbDecoder   = regexp(/[#]([0-9a-f]{6})/iy, 1)
                       .map(v =&gt; parseInt(v, 16))
                       .map(v =&gt; new RGB(v))
const greyDecoder  = matchInsensitive(&#39;grey&#39;).or(DecodeError.combine, matchInsensitive(&#39;gray&#39;))
                       .skipNext(optionalWhitespace)
                       .pickNext(ratioDecoder)
                       .map(v =&gt; new Grey(v))
const hslDecoder   = matchInsensitive(&#39;hsl(&#39;)
                       .pickNext(
                         ratioDecoder
                           .separatedByTimes(match(&#39;,&#39;), 3)
                           .map(v =&gt; new HSL(v[0], v[1], v[2]))
                       )
                       .skipNext(match(&#39;)&#39;))

const colorTextDecoder = decodeText(
    oneOf&lt;TextInput, Color[], DecodeError&gt;(
      DecodeError.combine,
      rgbDecoder,
      greyDecoder,
      hslDecoder
    ).skipNext(eoi) // make sure that there is nothing left to decode
  )

// all results are wrapped in a DecodeSuccess
// colorTextDecoder(&#39;#003355&#39;)          == new RGB(0x003355)
// colorTextDecoder(&#39;gray 0.3&#39;)         == new Grey(0.3)
// colorTextDecoder(&#39;gray0.2&#39;)          == new Grey(0.2)
// colorTextDecoder(&#39;HSL(0.1,0.2,0.3)&#39;) == new HSL(0.1,0.2,0.3)</code></pre></div><p>Another scenario where decoding comes in handy is to validate, type and transform payloads from JSON requests. You can decode a value (after being parsed by <code>JSON.parse</code>) into one of the <code>Color</code> types described above.</p>
<p>A few examples of valid JSON payloads:</p>
<div><pre class="line-numbers"><code class="language-json">&quot;#003366&quot;</code></pre></div><div><pre class="line-numbers"><code class="language-json">{ &quot;grey&quot;: 0.5 }</code></pre></div><div><pre class="line-numbers"><code class="language-json">{ &quot;kind&quot;: &quot;hsl&quot;, &quot;h&quot;: 0.2, &quot;s&quot;: 0.5, &quot;l&quot;: 0.8 }</code></pre></div><p>Here is a <code>colorValueDecoder</code> definition that can deal with those cases:</p>
<div><pre class="line-numbers"><code class="language-typescript">const ratioValue = numberValue.test(v =&gt; v &gt;= 0 &amp;&amp; v &lt;= 1, DecodeError.expectedWithinRange(&#39;0&#39;, &#39;1&#39;))

// reuse the rgbDecoder defined above to validate and trasform the string value into an RGB instance
// example: &quot;#003366&quot;
const rgbValue = stringValue.sub(rgbDecoder, input =&gt; ({ input, index: 0 }), v =&gt; v)

// example: { &quot;grey&quot;: 0.5 }
const greyValue = objectValue(
    { grey: ratioValue },
    [] // the empty array means that no fields are optional
  ).map(v =&gt; new Grey(v.grey))

// example: { &quot;kind&quot;: &quot;hsl&quot;, &quot;h&quot;: 0.2, &quot;s&quot;: 0.5, &quot;l&quot;: 0.8 }
const hslValue = objectValue(
    {
      kind: literalValue(&#39;hsl&#39;),
      h: ratioValue,
      s: ratioValue,
      l: ratioValue
    },
    []
  ).map(v =&gt; new HSL(v.h, v.s, v.l))

const colorValueDecoder = decodeValue(
    oneOf&lt;ValueInput, Color[], DecodeError&gt;(
      DecodeError.combine,
      rgbValue,
      greyValue,
      hslValue
    )
  )</code></pre></div>

















                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 0;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'getting-started';
            var COMPODOC_CURRENT_PAGE_URL = 'index.html';
       </script>

       <script src="./js/libs/custom-elements.min.js"></script>
       <script src="./js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="./js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="./js/menu-wc.js" defer></script>

       <script src="./js/libs/bootstrap-native.js"></script>

       <script src="./js/libs/es6-shim.min.js"></script>
       <script src="./js/libs/EventDispatcher.js"></script>
       <script src="./js/libs/promise.min.js"></script>
       <script src="./js/libs/zepto.min.js"></script>

       <script src="./js/compodoc.js"></script>

       <script src="./js/tabs.js"></script>
       <script src="./js/menu.js"></script>
       <script src="./js/libs/clipboard.min.js"></script>
       <script src="./js/libs/prism.js"></script>
       <script src="./js/sourceCode.js"></script>
          <script src="./js/search/search.js"></script>
          <script src="./js/search/lunr.min.js"></script>
          <script src="./js/search/search-lunr.js"></script>
          <script src="./js/search/search_index.js"></script>
       <script src="./js/lazy-load-graphs.js"></script>


    </body>
</html>
